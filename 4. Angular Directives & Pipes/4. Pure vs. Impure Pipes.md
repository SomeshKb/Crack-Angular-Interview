# ðŸš€ Pure vs. Impure Pipes in Angular  

In Angular, **pipes** help format and transform data in templates. Pipes can be classified into **two types** based on how they handle change detection:

1. **Pure Pipes** â€“ Executed only when the input changes.
2. **Impure Pipes** â€“ Executed on every change detection cycle.

Understanding these differences is **crucial for performance optimization**. Let's dive in! ðŸŽ¯  

---

## ðŸ”¹ **1. What is a Pure Pipe?**  

âœ… **A pure pipe is executed only when its input changes.**  
âœ… It **does not trigger change detection** if the reference remains the same.  
âœ… This improves **performance**, as the transformation runs only when needed.  

ðŸ“Œ **Example of a Pure Pipe:**  

```typescript
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'pureExample'
})
export class PureExamplePipe implements PipeTransform {
  transform(value: string): string {
    console.log('Pure Pipe Executed');
    return value.toUpperCase();
  }
}
```

ðŸ“Œ **Using the Pipe in a Template:**  

```html
<p>{{ 'hello world' | pureExample }}</p>  <!-- Output: HELLO WORLD -->
```

âœ… **Effect:** The pipe runs **only when `hello world` changes**.

---

## ðŸ”¥ **2. What is an Impure Pipe?**  

âš ï¸ **An impure pipe is executed on every change detection cycle, even if the input remains the same.**  
âš ï¸ It is used when working with **mutable data structures**, like arrays and objects.  

ðŸ“Œ **How to make a pipe impure?**  

```typescript
@Pipe({
  name: 'impureExample',
  pure: false // ðŸš¨ Setting this to false makes it an impure pipe!
})
export class ImpureExamplePipe implements PipeTransform {
  transform(value: number[]): number[] {
    console.log('Impure Pipe Executed');
    return value.filter(num => num % 2 === 0); // Returns even numbers
  }
}
```

ðŸ“Œ **Using the Pipe in a Template:**  

```html
<p>{{ numbers | impureExample }}</p>
```

Even if `numbers` **does not change**, the pipe **still runs on every cycle**! ðŸš¨  

---

## ðŸ“Š **3. Performance Comparison â€“ Pure vs. Impure Pipes**  

| ðŸš€ Feature | âœ… Pure Pipes | âš ï¸ Impure Pipes |
|------------|--------------|----------------|
| Execution Frequency | Only when input changes | Runs on every change detection cycle |
| Performance | **Fast & efficient** ðŸš€ | **Can be slow** for large datasets |
| Suitable for | **Immutable data** (strings, numbers, booleans) | **Mutable data** (arrays, objects) |
| Use Case Example | Formatting text, converting currency | Filtering lists, updating real-time data |

---

## ðŸ† **4. When to Use Pure vs. Impure Pipes?**  

âœ… **Use Pure Pipes When:**  
âœ”ï¸ Formatting text (uppercase, lowercase).  
âœ”ï¸ Displaying a **static list** of items.  
âœ”ï¸ Performing **lightweight transformations**.  

âš ï¸ **Use Impure Pipes When:**  
âœ”ï¸ Filtering or sorting **dynamic lists**.  
âœ”ï¸ Handling **real-time data** from APIs.  
âœ”ï¸ Working with **mutable objects or arrays**.  

---

## ðŸ“Œ **5. Alternative to Impure Pipes â€“ Use a Method Instead!**  

ðŸ”¹ Instead of using an **impure pipe**, consider using a **method in the component** to improve performance.  

```typescript
export class AppComponent {
  numbers = [1, 2, 3, 4, 5, 6];

  getEvenNumbers(): number[] {
    return this.numbers.filter(num => num % 2 === 0);
  }
}
```

ðŸ“Œ **Using the method in the template:**  

```html
<p>{{ getEvenNumbers() }}</p>
```

âœ… **Why is this better?**  
- Angular **only runs the function when needed**, rather than on **every cycle**.  
- Improves **performance and efficiency**.  

---

## ðŸŽ¯ **6. Summary & Best Practices**  

| âœ… Best Practice | ðŸ’¡ Recommendation |
|----------------|------------------|
| **Prefer pure pipes** | Use impure pipes only when necessary |
| **Use impure pipes for dynamic data** | But be aware of performance impact |
| **Consider a method instead of an impure pipe** | More optimized for change detection |
| **Avoid complex logic inside pipes** | Move heavy computations to services |

