
---

# ğŸ“¦ Modules & ğŸ›ï¸ Namespaces in TypeScript  

TypeScript provides **Modules** and **Namespaces** to organize code efficiently, ensuring better **maintainability**, **scalability**, and **reusability**.  

Letâ€™s explore these concepts in detail! ğŸ”¥  

---

## ğŸ“¦ **1. What are Modules?**  

A **module** in TypeScript is a way to **group related code** into separate files, making it **more manageable** and **reusable** across the application.  

âœ… **Why Use Modules?**  
âœ”ï¸ Encourages **code reusability** ğŸ“‚  
âœ”ï¸ Supports **lazy loading** ğŸ•’  
âœ”ï¸ Avoids **global scope pollution** ğŸš€  
âœ”ï¸ Works seamlessly with **ES6+ import/export** ğŸ”„  

---

## ğŸš€ **2. Creating and Using Modules**  

### **ğŸ”¹ Creating a Module (`math.ts`)**  

```typescript
// math.ts (Exporting)
export function add(a: number, b: number): number {
  return a + b;
}

export function multiply(a: number, b: number): number {
  return a * b;
}
```

### **ğŸ”¹ Importing a Module (`app.ts`)**  

```typescript
// app.ts (Importing)
import { add, multiply } from "./math";

console.log(add(5, 3));       // 8
console.log(multiply(4, 2));  // 8
```

âœ… **Best Practices for Modules:**  
âœ”ï¸ Keep **related functions** in the same module ğŸ“¦  
âœ”ï¸ Use **named exports** for flexibility ğŸš€  
âœ”ï¸ Use **default exports** when a module has **one main function** ğŸ”„  

---

## ğŸ›ï¸ **3. Default vs Named Exports**  

| Feature | Named Export | Default Export |
|---------|-------------|---------------|
| Export Multiple Items? | âœ… Yes | âŒ No |
| Syntax | `export { name }` | `export default function` |
| Import Syntax | `{ name }` | `anyNameYouWant` |
| Preferred Use Case | When exporting multiple items | When exporting a single main item |

### **ğŸ”¹ Named Export Example**  
```typescript
export function greet(name: string) {
  return `Hello, ${name}!`;
}
```

```typescript
import { greet } from "./utils";
console.log(greet("Alice")); // Hello, Alice!
```

### **ğŸ”¹ Default Export Example**  
```typescript
export default function greet(name: string) {
  return `Hello, ${name}!`;
}
```

```typescript
import greet from "./utils"; // No need for { }
console.log(greet("Bob")); // Hello, Bob!
```

---

## ğŸ¯ **4. Module Resolution in TypeScript**  

TypeScript follows a **resolution strategy** to locate and import modules.  

| Strategy | Description |
|----------|------------|
| **Classic** | Used when the `module` option is set to `none` or `AMD`. |
| **Node** | Used when the `module` option is set to `CommonJS` or `ES6`. |

âœ… **Best Practice:** Use **ES6 modules** (`import/export`) for modern projects.  

---

## ğŸ›ï¸ **5. What are Namespaces?**  

A **namespace** is a way to **logically group related code** to prevent **global scope pollution**.  

âœ… **Why Use Namespaces?**  
âœ”ï¸ Helps in **organizing large projects** ğŸ“‚  
âœ”ï¸ Prevents **naming conflicts** ğŸ”„  
âœ”ï¸ Ideal for **internal module organization** ğŸ›ï¸  

---

## ğŸš€ **6. Creating and Using Namespaces**  

### **ğŸ”¹ Creating a Namespace (`Shapes.ts`)**  

```typescript
namespace Shapes {
  export class Circle {
    constructor(public radius: number) {}

    area(): number {
      return Math.PI * this.radius * this.radius;
    }
  }

  export class Square {
    constructor(public side: number) {}

    area(): number {
      return this.side * this.side;
    }
  }
}
```

### **ğŸ”¹ Using the Namespace (`app.ts`)**  

```typescript
const myCircle = new Shapes.Circle(5);
console.log(myCircle.area()); // 78.54

const mySquare = new Shapes.Square(4);
console.log(mySquare.area()); // 16
```

âœ… **Best Practices for Namespaces:**  
âœ”ï¸ Use **Namespaces for internal code organization** ğŸ›ï¸  
âœ”ï¸ Use **Modules for external imports and exports** ğŸ“¦  

---

## ğŸ”„ **7. Modules vs Namespaces: Which One to Use?**  

| Feature | Modules | Namespaces |
|---------|---------|------------|
| Scope | Works across files | Works within a single file |
| Import Required? | âœ… Yes (import/export) | âŒ No (global scope) |
| Preferred Use Case | Large-scale applications | Internal project organization |

âœ… **Best Practice:** Use **Modules** for modern projects & **Namespaces** for legacy codebases.  

---

## ğŸ¯ **8. Summary: Key Takeaways**  

ğŸ”¥ **Modules** (Recommended for modern applications)  
âœ”ï¸ Uses `import/export`  
âœ”ï¸ Supports **tree-shaking** ğŸ“¦  
âœ”ï¸ Works well with **ES6 and TypeScript** ğŸš€  

ğŸ”¥ **Namespaces** (Useful for internal organization)  
âœ”ï¸ Uses `namespace` keyword  
âœ”ï¸ Avoids **global name conflicts** ğŸ›ï¸  
âœ”ï¸ Best for **legacy codebases** ğŸ“œ  

