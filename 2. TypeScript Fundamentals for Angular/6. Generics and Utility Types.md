# ğŸ”¢ Generics & ğŸ› ï¸ Utility Types in TypeScript  

Generics allow you to write **flexible, reusable, and type-safe code**, while **utility types** help modify and enhance types efficiently.  

---

## ğŸš€ **1. What are Generics?**  

Generics enable **type parameters**, allowing functions, classes, and interfaces to work with **multiple types** instead of a specific one.  

âœ… **Why Use Generics?**  
âœ”ï¸ Provides **type safety**  
âœ”ï¸ Improves **reusability**  
âœ”ï¸ Reduces **code duplication**  
âœ”ï¸ Works with **multiple types dynamically**  

---

## ğŸ—ï¸ **2. Using Generics in Functions**  

### **ğŸ”¹ Example: Generic Function**  

```typescript
function identity<T>(value: T): T {
  return value;
}

console.log(identity<number>(42));   // Output: 42
console.log(identity<string>("Hello")); // Output: Hello
```

âœ… **Use Case:** Works with any type (`number`, `string`, `boolean`, etc.)  

---

## ğŸ›ï¸ **3. Generics in Classes**  

### **ğŸ”¹ Example: Generic Class**  

```typescript
class Box<T> {
  private content: T;

  constructor(value: T) {
    this.content = value;
  }

  getValue(): T {
    return this.content;
  }
}

const numberBox = new Box<number>(100);
console.log(numberBox.getValue()); // Output: 100

const stringBox = new Box<string>("TypeScript");
console.log(stringBox.getValue()); // Output: TypeScript
```

âœ… **Use Case:** Creating **type-safe data structures** like stacks, queues, and caches.  

---

## ğŸ“¦ **4. Generics in Interfaces**  

### **ğŸ”¹ Example: Generic Interface**  

```typescript
interface Repository<T> {
  data: T[];
  add(item: T): void;
  getAll(): T[];
}

class UserRepo implements Repository<string> {
  data: string[] = [];

  add(item: string): void {
    this.data.push(item);
  }

  getAll(): string[] {
    return this.data;
  }
}

const repo = new UserRepo();
repo.add("Alice");
repo.add("Bob");
console.log(repo.getAll()); // Output: ["Alice", "Bob"]
```

âœ… **Use Case:** Defining **generic contracts** for APIs, databases, and services.  

---

## âš™ï¸ **5. Generics in Type Constraints**  

Generics can be **restricted** to specific types using the `extends` keyword.  

### **ğŸ”¹ Example: Constraint to Objects**  

```typescript
function printObject<T extends { name: string }>(obj: T): void {
  console.log(`Name: ${obj.name}`);
}

printObject({ name: "Angular", version: 17 }); // âœ… Works
printObject("Hello"); // âŒ Error: Argument does not match constraint
```

âœ… **Use Case:** Ensuring that the type has **specific properties**.  

---

## ğŸ“Œ **6. Utility Types in TypeScript**  

Utility types **modify or enhance existing types** to make them more flexible.  

| ğŸ› ï¸ **Utility Type** | ğŸ¯ **Purpose** | ğŸ“Œ **Example** |
|-----------------|-----------------|---------------|
| `Partial<T>` | Makes all properties optional | `Partial<User>` |
| `Required<T>` | Makes all properties required | `Required<User>` |
| `Readonly<T>` | Prevents modification of properties | `Readonly<User>` |
| `Pick<T, K>` | Selects specific properties | `Pick<User, "name">` |
| `Omit<T, K>` | Excludes specific properties | `Omit<User, "age">` |
| `Record<K, T>` | Creates an object type with fixed keys | `Record<string, number>` |

---

## ğŸ” **7. Exploring Key Utility Types**  

### **ğŸ“Œ Partial<T> â€“ Makes Properties Optional**  

```typescript
interface User {
  name: string;
  age: number;
}

const partialUser: Partial<User> = { name: "Alice" }; // âœ… No error
```

âœ… **Use Case:** Used when **updating** objects with **only a few fields**.  

---

### **ğŸ“Œ Required<T> â€“ Makes Properties Mandatory**  

```typescript
interface User {
  name?: string;
  age?: number;
}

const fullUser: Required<User> = { name: "Bob", age: 30 }; // âœ… Requires all properties
```

âœ… **Use Case:** Enforces **all properties to be defined**.  

---

### **ğŸ“Œ Readonly<T> â€“ Prevents Modification**  

```typescript
interface User {
  name: string;
}

const user: Readonly<User> = { name: "Charlie" };
user.name = "Dave"; // âŒ Error: Cannot assign to 'name' because it is a read-only property.
```

âœ… **Use Case:** Protects **immutable** data structures.  

---

### **ğŸ“Œ Pick<T, K> â€“ Select Specific Properties**  

```typescript
interface User {
  name: string;
  age: number;
  email: string;
}

const pickedUser: Pick<User, "name" | "email"> = { name: "Eve", email: "eve@example.com" };
```

âœ… **Use Case:** Extracts **only required properties**.  

---

### **ğŸ“Œ Omit<T, K> â€“ Exclude Specific Properties**  

```typescript
const omittedUser: Omit<User, "age"> = { name: "Frank", email: "frank@example.com" };
```

âœ… **Use Case:** Removes **unwanted properties** when passing data.  

---

### **ğŸ“Œ Record<K, T> â€“ Defines Fixed Key-Value Pairs**  

```typescript
const userRoles: Record<string, string> = {
  admin: "Full Access",
  user: "Limited Access",
};
```

âœ… **Use Case:** Creates **typed dictionaries or maps**.  

---

## ğŸš€ **8. Summary & Key Takeaways**  

âœ… **Generics allow code to work with multiple types dynamically.**  
âœ… **They are used in functions, classes, and interfaces.**  
âœ… **Utility types modify existing types to make development easier.**  
âœ… **Partial, Required, Readonly, Pick, Omit, and Record are key utility types.**  

ğŸ’¡ **Mastering Generics & Utility Types will make your TypeScript skills unstoppable!** ğŸš€  

